package paths

import (
	"bytes"
	"fmt"
	"go/format"
	"path/filepath"
	"strings"
)

// GeneratorConfig holds configuration for code generation.
type GeneratorConfig struct {
	PackageName string
	TypeName    string
	SourceFile  string
	TagName     string
	Output      string
}

// generateCode generates Go source code from the analysis result.
func generateCode(analysis *AnalysisResult, config GeneratorConfig) ([]byte, error) {
	var buf bytes.Buffer

	// Write header
	writeHeader(&buf, config)

	// Determine required imports
	needsStrconv := false
	needsJsonptr := false

	var staticPaths, dynamicPaths []PathInfo
	for _, p := range analysis.Paths {
		if len(p.DynamicParams) > 0 {
			dynamicPaths = append(dynamicPaths, p)
			needsJsonptr = true
			for _, param := range p.DynamicParams {
				if param.Type == "int" {
					needsStrconv = true
				}
			}
		} else {
			staticPaths = append(staticPaths, p)
		}
	}

	// Write imports
	writeImports(&buf, needsStrconv, needsJsonptr)

	// Write constants for static paths
	if len(staticPaths) > 0 {
		writeConstants(&buf, staticPaths)
	}

	// Write functions for dynamic paths
	for _, p := range dynamicPaths {
		writeFunction(&buf, p)
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted code for debugging
		return buf.Bytes(), fmt.Errorf("failed to format generated code: %w\n%s", err, buf.String())
	}

	return formatted, nil
}

func writeHeader(buf *bytes.Buffer, config GeneratorConfig) {
	buf.WriteString("// Code generated by jubako generate paths. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("// Source: %s\n", filepath.Base(config.SourceFile)))
	buf.WriteString(fmt.Sprintf("// Type: %s\n", config.TypeName))

	// Build the go:generate directive
	cmd := "//go:generate go tool jubako generate paths"
	cmd += fmt.Sprintf(" -type %s", config.TypeName)
	if config.TagName != "json" {
		cmd += fmt.Sprintf(" -tag %s", config.TagName)
	}
	cmd += fmt.Sprintf(" %s", filepath.Base(config.SourceFile))
	buf.WriteString(cmd + "\n")

	buf.WriteString("\n")
	buf.WriteString(fmt.Sprintf("package %s\n", config.PackageName))
}

func writeImports(buf *bytes.Buffer, needsStrconv, needsJsonptr bool) {
	if !needsStrconv && !needsJsonptr {
		buf.WriteString("\n")
		return
	}

	buf.WriteString("\nimport (\n")
	if needsStrconv {
		buf.WriteString("\t\"strconv\"\n")
	}
	if needsJsonptr {
		if needsStrconv {
			buf.WriteString("\n")
		}
		buf.WriteString("\t\"github.com/yacchi/jubako/jsonptr\"\n")
	}
	buf.WriteString(")\n")
}

func writeConstants(buf *bytes.Buffer, paths []PathInfo) {
	buf.WriteString("\n// Path constants for static configuration paths.\n")
	buf.WriteString("const (\n")
	for _, p := range paths {
		// Escape the path for Go string literal
		escapedPath := escapeGoString(p.JSONPointer)
		buf.WriteString(fmt.Sprintf("\t%s = %q\n", p.ConstName, escapedPath))
	}
	buf.WriteString(")\n")
}

func writeFunction(buf *bytes.Buffer, p PathInfo) {
	buf.WriteString("\n")

	// Write comment
	buf.WriteString(fmt.Sprintf("// %s returns the JSONPointer path.\n", p.FuncName))
	buf.WriteString(fmt.Sprintf("// %s\n", p.Comment))

	// Build parameter list
	params := buildParamList(p.DynamicParams)

	// Write function signature
	buf.WriteString(fmt.Sprintf("func %s(%s) string {\n", p.FuncName, params))

	// Write function body
	body := buildFunctionBody(p.JSONPointer, p.DynamicParams)
	buf.WriteString(fmt.Sprintf("\treturn %s\n", body))

	buf.WriteString("}\n")
}

func buildParamList(params []ParamInfo) string {
	var parts []string
	for _, p := range params {
		parts = append(parts, fmt.Sprintf("%s %s", p.Name, p.Type))
	}
	return strings.Join(parts, ", ")
}

func buildFunctionBody(path string, params []ParamInfo) string {
	// Split path and identify dynamic segments
	segments := strings.Split(path, "/")

	var parts []string
	var currentStatic string
	paramIdx := 0

	for i, seg := range segments {
		if seg == "" && i == 0 {
			// Leading empty segment from initial /
			currentStatic = ""
			continue
		}

		if strings.HasPrefix(seg, "{") && strings.HasSuffix(seg, "}") {
			// Dynamic segment
			// Flush accumulated static part with trailing slash
			if currentStatic != "" {
				parts = append(parts, fmt.Sprintf("%q", "/"+currentStatic+"/"))
				currentStatic = ""
			} else if len(parts) == 0 {
				// First segment is dynamic, start with /
				parts = append(parts, `"/"`)
			} else {
				// Add separator between dynamic segments
				parts = append(parts, `"/"`)
			}

			// Add dynamic part
			if paramIdx < len(params) {
				param := params[paramIdx]
				if param.Type == "string" {
					parts = append(parts, fmt.Sprintf("jsonptr.Escape(%s)", param.Name))
				} else {
					parts = append(parts, fmt.Sprintf("strconv.Itoa(%s)", param.Name))
				}
				paramIdx++
			}
		} else {
			// Static segment
			if currentStatic != "" {
				currentStatic += "/" + seg
			} else {
				currentStatic = seg
			}
		}
	}

	// Flush remaining static part
	if currentStatic != "" {
		if len(parts) > 0 {
			parts = append(parts, fmt.Sprintf("%q", "/"+currentStatic))
		} else {
			parts = append(parts, fmt.Sprintf("%q", "/"+currentStatic))
		}
	}

	return strings.Join(parts, " + ")
}

// escapeGoString escapes a string for use in a Go string literal.
// JSONPointer paths may contain special characters that need escaping.
func escapeGoString(s string) string {
	// The path is already valid - just return as-is
	// fmt.Sprintf with %q handles escaping
	return s
}
